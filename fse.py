########################################
# FPGA Synthesis Engine
########################################
# Yongning Young Ma
# yma00@bu.edu
# Boston University
# EC551, Fall 2023
########################################
# Citations
# Contains code generated by ChatGPT 4.0 and Github Copilot
# https://stackoverflow.com/questions/5574702/how-do-i-print-to-stderr-in-python  <- eprint
########################################

import json
import fpga_adt as fpga
import eq_adt as eq
import numpy as np
import math
import sys
import itertools


class eq_part_adt(eq.eq_adt):
    def __init__(self, eq, literals, neglist, ops, table, isCircuit):
        super().__init__(eq)
        self.literals = literals
        self.neglist = neglist
        self.ops = ops
        self.table = table
        self.isCircuit = isCircuit
        self.lutPrim = []


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


# analyze input equations and determine the order they are routed
# most complex equations are routed first
def analyze_eq(eq_adt: list):
    # get the number of literals and ops in each equation
    # higher generally means more complex
    complexity = []
    for each in eq_adt:
        complexity.append(len(each.literals) + len(each.ops))

    # sort the equations by complexity
    # the most complex equations are routed first

    # sort the equations by complexity
    output = [
        x
        for _, x in sorted(
            zip(complexity, eq_adt), key=lambda pair: pair[0], reverse=True
        )
    ]
    return output


# partitions the truth table of each eq_adt into
# either 4 or 6 input luts
# input: eq_adt, lut_type, fpga_adt
# output: partitioned_luts, num_luts


def partition_to_lut(eq_adt: eq, lut_type: int, fpga_adt: fpga):
    oliteral = list(
        set(eq_adt.literals)
    )  # Assuming this gives a list of all possible input literals
    num_literals = len(oliteral)

    lut_inputs = []
    lut_outputs = []
    lut_data = []

    lut_input_combinations = itertools.combinations(oliteral, lut_type)
    for combination in lut_input_combinations:
        filtered_table = {
            k: v
            for k, v in eq_adt.table.items()
            if is_combination_relevant(k, combination, num_literals, oliteral)
        }
        if filtered_table:
            lut_index = len(lut_inputs)  # Index for the next LUT
            lut_inputs.append(list(combination))
            lut_outputs.append(f"LUT_{lut_index}_Output")
            relevant_minterms = get_relevant_minterms(
                combination, num_literals, oliteral, eq_adt.table
            )
            binary_data = "".join(
                str(eq_adt.table.get(minterm, 0)) for minterm in relevant_minterms
            )
            binary_data = adjust_binary_length(binary_data, lut_type)
            lut_data.append(binary_data)

    # Determining MUX LUTs
    num_normal_luts = len(lut_inputs)
    num_select_lines = math.ceil(math.log2(num_normal_luts))
    num_mux_luts = math.ceil(num_normal_luts / lut_type)

    # Generate MUX LUT configurations
    for i in range(num_mux_luts):
        mux_inputs = [
            lut_outputs[j]
            for j in range(i * lut_type, min((i + 1) * lut_type, num_normal_luts))
        ]
        mux_outputs = f"MUX_{i}_Output"
        mux_binary_data = generate_mux_data(
            num_select_lines, len(mux_inputs)
        )  # Placeholder, implement the logic based on your MUX design
        lut_inputs.append(mux_inputs)
        lut_outputs.append(mux_outputs)
        lut_data.append(mux_binary_data)

    num_luts = len(lut_outputs)

    return lut_inputs, lut_outputs, lut_data, num_luts


def is_combination_relevant(minterm, combination, num_literals, oliteral):
    binary_repr = format(minterm, f"0{num_literals}b")
    return all(binary_repr[oliteral.index(lit)] != "0" for lit in combination)


def get_relevant_minterms(combination, num_literals, oliteral, table):
    relevant_minterms = []
    for minterm in range(2**num_literals):
        if (
            is_combination_relevant(minterm, combination, num_literals, oliteral)
            and minterm in table
        ):
            relevant_minterms.append(minterm)
    return relevant_minterms


def generate_mux_data(num_select_lines, num_inputs):
    binary_data = ''
    for select_combination in range(2 ** num_select_lines):
        # Determine which input is selected by this combination
        selected_input = select_combination % num_inputs
        # For each combination, only one input is selected
        input_state = ['0'] * num_inputs
        if selected_input < num_inputs:
            input_state[selected_input] = '1'  # Set '1' for the selected input
        binary_data += ''.join(input_state)

    return binary_data



def adjust_binary_length(binary_data, lut_type):
    # Ensure the binary data length matches 2^lut_type
    required_length = 2**lut_type
    return binary_data.ljust(required_length, "0")  # Pad with '0's if necessary


# LUT routing with no connection constraints
# and can be mapped to any LUT from any inputs
# algorithm:
# partition the truth table of each eq_adt into
# either 4 or 6 input luts and route them
# input list of eqs are sorted based on complexity
def routing_free(eq_adt: list, fpga_adt: fpga):
    sorted = analyze_eq(eq_adt)

    # partition eq into luts
    for each in sorted:
        lut_inputs, lut_outputs, lut_data, num_luts = partition_to_lut(each, 4, fpga_adt)

    pass


# LUT routing with connection constraints
def routing_constrained(eq_adt: list):
    sorted = analyze_eq(eq_adt)
    pass


#
def fse(fpga_adt: fpga):
    pass
