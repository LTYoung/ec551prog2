########################################
# FPGA Synthesis Engine
########################################
# Yongning Young Ma
# yma00@bu.edu
# Boston University
# EC551, Fall 2023
########################################
# Citations
# Contains code generated by ChatGPT 4.0
# https://stackoverflow.com/questions/5574702/how-do-i-print-to-stderr-in-python  <- eprint
########################################

import json
import fpga_adt as fpga
import eq_adt as eq
import numpy as np
import math
import sys


class eq_part_adt(eq.eq_adt):
    def __init__(self, eq, literals, neglist, ops, table, isCircuit):
        super().__init__(eq)
        self.literals = literals
        self.neglist = neglist
        self.ops = ops
        self.table = table
        self.isCircuit = isCircuit
        self.lutPrim = []


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


# analyze input equations and determine the order they are routed
# most complex equations are routed first
def analyze_eq(eq_adt: list):
    # get the number of literals and ops in each equation
    # higher generally means more complex
    complexity = []
    for each in eq_adt:
        complexity.append(len(each.literals) + len(each.ops))

    # sort the equations by complexity
    # the most complex equations are routed first

    # sort the equations by complexity
    output = [
        x
        for _, x in sorted(
            zip(complexity, eq_adt), key=lambda pair: pair[0], reverse=True
        )
    ]
    return output


# partitions the truth table of each eq_adt into
# either 4 or 6 input luts
# input: eq_adt, lut_type, fpga_adt
# output: partitioned_luts, num_luts
import numpy as np
import math

def partition_to_lut(eq_adt: eq, lut_type: int, fpga_adt: fpga):
    oliteral = list(set(eq_adt.literals))
    num_literals = len(oliteral)

    if (lut_type == 4 and num_literals <= 4) or (lut_type == 6 and num_literals <= 6):
        return eq_adt, 1, {}

    table = eq_adt.table
    if lut_type in [4, 6]:
        num_luts = int(np.ceil(len(table) / lut_type))
        partitioned_table = []
        start_index = 0
        for _ in range(int(num_luts)):
            end_index = min(start_index + lut_type, len(table))
            partitioned_table.append(dict(list(table.items())[start_index:end_index]))
            start_index += lut_type

        num_select_lines = math.ceil(math.log2(num_luts))

        # Calculate the total number of LUTs needed, including MUX LUTs
        total_luts_needed = num_luts
        mux_layers = {}
        current_layer_luts = num_luts
        layer = 0

        while current_layer_luts > 1:
            layer_mux_luts = math.ceil(current_layer_luts / lut_type)
            total_luts_needed += layer_mux_luts
            mux_layers[layer] = {"num_mux_luts": layer_mux_luts, "controlled_luts": current_layer_luts}
            current_layer_luts = layer_mux_luts
            layer += 1

        if total_luts_needed > len(fpga_adt.get_luts()):
            eprint("Error: Not enough LUTs available")
            return None, total_luts_needed - len(fpga_adt.get_luts()), {}

        # Assign partitioned LUTs to MUX LUTs
        mux_assignments = {}
        for layer in mux_layers:
            for mux_index in range(mux_layers[layer]["num_mux_luts"]):
                controlled_luts = []
                for lut_index in range(mux_index * lut_type, min((mux_index + 1) * lut_type, mux_layers[layer]["controlled_luts"])):
                    controlled_luts.append(lut_index)
                mux_assignments[(layer, mux_index)] = controlled_luts
        
        mux_output_assignments = {}
        current_input_combinations = range(int(num_luts))  # Initial input combinations for the first layer

        for layer in mux_layers:
            layer_output_assignments = {}
            for mux_index in range(mux_layers[layer]["num_mux_luts"]):
                # Each MUX LUT at this layer will have output assignments based on the input combinations
                # For simplicity, let's assume each MUX LUT outputs a unique identifier for now
                output_id = f"Layer{layer}_MUX{mux_index}"
                layer_output_assignments[output_id] = current_input_combinations[mux_index * lut_type : (mux_index + 1) * lut_type]
            mux_output_assignments[layer] = layer_output_assignments

            # Update current_input_combinations for the next layer
            current_input_combinations = list(layer_output_assignments.keys())

    else:
        eprint("Error: LUT type not supported")
        return None, None, {}

    return partitioned_table, total_luts_needed, mux_assignments



# LUT routing with no connection constraints
# and can be mapped to any LUT from any inputs
# algorithm:
# partition the truth table of each eq_adt into
# either 4 or 6 input luts and route them
# input list of eqs are sorted based on complexity
def routing_free(eq_adt: list, fpga_adt: fpga):
    sorted = analyze_eq(eq_adt)

    # partition eq into luts
    for each in sorted:
        luts, num_luts = partition_to_lut(each, 4, fpga_adt)
        print(num_luts)

    pass


# LUT routing with connection constraints
def routing_constrained(eq_adt: list):
    sorted = analyze_eq(eq_adt)
    pass


#
def fse(fpga_adt: fpga):
    pass
